// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "../interfaces/ICentralVault.sol";
import "../interfaces/IOrderRouter.sol";

/**
 * @title SettlementEngine
 * @dev Handles batch settlement of off-chain matched trades
 * @notice Settles trades in batches for gas efficiency and atomic settlement
 */
contract SettlementEngine is AccessControl, ReentrancyGuard, Pausable {
    // Roles
    bytes32 public constant SETTLEMENT_ADMIN_ROLE = keccak256("SETTLEMENT_ADMIN_ROLE");
    bytes32 public constant BATCH_PROCESSOR_ROLE = keccak256("BATCH_PROCESSOR_ROLE");

    // Settlement batch structure
    struct SettlementBatch {
        bytes32 batchId;
        TradeSettlement[] trades;
        uint256 timestamp;
        BatchStatus status;
        uint256 gasUsed;
        bytes32 merkleRoot;
    }

    struct TradeSettlement {
        uint256 buyOrderId;
        uint256 sellOrderId;
        address buyer;
        address seller;
        string metricId;
        uint256 quantity;
        uint256 price;
        uint256 buyerFee;
        uint256 sellerFee;
        uint256 timestamp;
    }

    enum BatchStatus {
        PENDING,
        PROCESSING,
        COMPLETED,
        FAILED,
        CANCELLED
    }

    // State variables
    ICentralVault public immutable centralVault;
    IOrderRouter public immutable orderRouter;
    
    mapping(bytes32 => SettlementBatch) public settlementBatches;
    mapping(uint256 => bytes32) public orderToBatch;
    
    bytes32[] public allBatches;
    uint256 public batchCounter;
    
    // Configuration
    uint256 public maxBatchSize = 100;
    uint256 public batchTimeout = 300; // 5 minutes
    uint256 public settlementFeeRate = 10; // 0.1% in basis points

    // Events
    event BatchCreated(bytes32 indexed batchId, uint256 tradeCount, uint256 timestamp);
    event BatchProcessed(bytes32 indexed batchId, bool success, uint256 gasUsed);
    event TradeSettled(
        bytes32 indexed batchId,
        uint256 indexed buyOrderId,
        uint256 indexed sellOrderId,
        address buyer,
        address seller,
        uint256 quantity,
        uint256 price
    );

    constructor(
        address _centralVault,
        address _orderRouter,
        address admin
    ) {
        require(_centralVault != address(0), "SettlementEngine: Invalid vault");
        require(_orderRouter != address(0), "SettlementEngine: Invalid router");
        require(admin != address(0), "SettlementEngine: Invalid admin");

        centralVault = ICentralVault(_centralVault);
        orderRouter = IOrderRouter(_orderRouter);

        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(SETTLEMENT_ADMIN_ROLE, admin);
        _grantRole(BATCH_PROCESSOR_ROLE, admin);
    }

    /**
     * @dev Creates a settlement batch from matched trades
     */
    function createSettlementBatch(
        TradeSettlement[] calldata trades,
        bytes32 merkleRoot
    ) external onlyRole(BATCH_PROCESSOR_ROLE) returns (bytes32 batchId) {
        require(trades.length > 0, "SettlementEngine: Empty batch");
        require(trades.length <= maxBatchSize, "SettlementEngine: Batch too large");

        batchId = keccak256(abi.encodePacked(block.timestamp, batchCounter++));

        SettlementBatch storage batch = settlementBatches[batchId];
        batch.batchId = batchId;
        batch.timestamp = block.timestamp;
        batch.status = BatchStatus.PENDING;
        batch.merkleRoot = merkleRoot;

        for (uint256 i = 0; i < trades.length; i++) {
            TradeSettlement memory trade = trades[i];
            
            // Validate trade
            require(trade.buyer != address(0), "SettlementEngine: Invalid buyer");
            require(trade.seller != address(0), "SettlementEngine: Invalid seller");
            require(trade.quantity > 0, "SettlementEngine: Invalid quantity");
            require(trade.price > 0, "SettlementEngine: Invalid price");

            batch.trades.push(trade);
            orderToBatch[trade.buyOrderId] = batchId;
            orderToBatch[trade.sellOrderId] = batchId;
        }

        allBatches.push(batchId);

        emit BatchCreated(batchId, trades.length, block.timestamp);
        return batchId;
    }

    /**
     * @dev Processes a settlement batch
     */
    function processSettlementBatch(bytes32 batchId) 
        external 
        onlyRole(BATCH_PROCESSOR_ROLE) 
        nonReentrant 
    {
        SettlementBatch storage batch = settlementBatches[batchId];
        require(batch.status == BatchStatus.PENDING, "SettlementEngine: Batch not pending");
        require(block.timestamp <= batch.timestamp + batchTimeout, "SettlementEngine: Batch expired");

        batch.status = BatchStatus.PROCESSING;
        uint256 gasStart = gasleft();
        bool success = true;

        try this._settleBatchInternal(batchId) {
            batch.status = BatchStatus.COMPLETED;
        } catch {
            batch.status = BatchStatus.FAILED;
            success = false;
        }

        uint256 gasUsed = gasStart - gasleft();
        batch.gasUsed = gasUsed;

        emit BatchProcessed(batchId, success, gasUsed);
    }

    /**
     * @dev Internal batch settlement logic
     */
    function _settleBatchInternal(bytes32 batchId) external {
        require(msg.sender == address(this), "SettlementEngine: Internal only");
        
        SettlementBatch storage batch = settlementBatches[batchId];
        
        for (uint256 i = 0; i < batch.trades.length; i++) {
            TradeSettlement memory trade = batch.trades[i];
            
            // Calculate trade value and fees
            uint256 tradeValue = (trade.quantity * trade.price) / 1e18;
            uint256 totalFees = trade.buyerFee + trade.sellerFee;
            
            // Get primary collateral token
            (address primaryCollateral,,,) = centralVault.getPrimaryCollateralToken();
            
            // Transfer trade value from buyer to seller (minus seller fee)
            centralVault.transferAssets(
                trade.buyer,
                trade.seller,
                primaryCollateral,
                tradeValue - trade.sellerFee
            );
            
            // Collect fees
            if (totalFees > 0) {
                centralVault.transferAssets(
                    trade.buyer,
                    address(this),
                    primaryCollateral,
                    trade.buyerFee
                );
                
                if (trade.sellerFee > 0) {
                    centralVault.transferAssets(
                        trade.seller,
                        address(this),
                        primaryCollateral,
                        trade.sellerFee
                    );
                }
            }

            // Update order router with trade execution
            orderRouter.executeTradeMatch(
                trade.buyOrderId,
                trade.sellOrderId,
                trade.quantity,
                trade.price
            );

            emit TradeSettled(
                batchId,
                trade.buyOrderId,
                trade.sellOrderId,
                trade.buyer,
                trade.seller,
                trade.quantity,
                trade.price
            );
        }
    }

    /**
     * @dev Gets settlement batch details
     */
    function getSettlementBatch(bytes32 batchId) 
        external 
        view 
        returns (
            BatchStatus status,
            uint256 tradeCount,
            uint256 timestamp,
            uint256 gasUsed
        ) 
    {
        SettlementBatch memory batch = settlementBatches[batchId];
        return (batch.status, batch.trades.length, batch.timestamp, batch.gasUsed);
    }

    /**
     * @dev Gets all settlement batches
     */
    function getAllBatches() external view returns (bytes32[] memory) {
        return allBatches;
    }

    /**
     * @dev Gets batch for an order
     */
    function getOrderBatch(uint256 orderId) external view returns (bytes32) {
        return orderToBatch[orderId];
    }

    /**
     * @dev Updates settlement configuration
     */
    function updateConfiguration(
        uint256 _maxBatchSize,
        uint256 _batchTimeout,
        uint256 _settlementFeeRate
    ) external onlyRole(SETTLEMENT_ADMIN_ROLE) {
        require(_maxBatchSize > 0 && _maxBatchSize <= 1000, "SettlementEngine: Invalid batch size");
        require(_batchTimeout >= 60 && _batchTimeout <= 3600, "SettlementEngine: Invalid timeout");
        require(_settlementFeeRate <= 1000, "SettlementEngine: Fee too high"); // Max 10%

        maxBatchSize = _maxBatchSize;
        batchTimeout = _batchTimeout;
        settlementFeeRate = _settlementFeeRate;
    }

    /**
     * @dev Emergency cancel batch
     */
    function cancelBatch(bytes32 batchId) 
        external 
        onlyRole(SETTLEMENT_ADMIN_ROLE) 
    {
        SettlementBatch storage batch = settlementBatches[batchId];
        require(batch.status == BatchStatus.PENDING, "SettlementEngine: Cannot cancel batch");
        
        batch.status = BatchStatus.CANCELLED;
    }

    /**
     * @dev Withdraw collected fees
     */
    function withdrawFees(address recipient, uint256 amount) 
        external 
        onlyRole(SETTLEMENT_ADMIN_ROLE) 
    {
        require(recipient != address(0), "SettlementEngine: Invalid recipient");
        
        (address primaryCollateral,,,) = centralVault.getPrimaryCollateralToken();
        centralVault.transferAssets(address(this), recipient, primaryCollateral, amount);
    }

    /**
     * @dev Emergency pause
     */
    function pause() external onlyRole(SETTLEMENT_ADMIN_ROLE) {
        _pause();
    }

    /**
     * @dev Emergency unpause
     */
    function unpause() external onlyRole(SETTLEMENT_ADMIN_ROLE) {
        _unpause();
    }
}
