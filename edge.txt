import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { createPublicClient, http, parseAbi } from "npm:viem";
const SUPABASE_URL = Deno.env.get("SUPABASE_URL") || Deno.env.get("NEXT_PUBLIC_SUPABASE_URL");
const SUPABASE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") || Deno.env.get("NEXT_PUBLIC_SUPABASE_ANON_KEY");
const RPC_URL = Deno.env.get("RPC_URL");
const ALCHEMY_SIGNING_KEY = Deno.env.get("ALCHEMY_WEBHOOK_SIGNING_KEY_PRICE_UPDATE");
const ENABLE_POLLING = (Deno.env.get("ENABLE_POLLING") || "").toLowerCase() === "true";
const CRON_SECRET = Deno.env.get("CRON_SECRET") || "";
if (!SUPABASE_URL || !SUPABASE_KEY || !RPC_URL) {
  console.error("Missing env: SUPABASE_URL/SUPABASE_KEY/RPC_URL required");
}
const BOOT_TS = Date.now();
console.log("[update-tickers][boot] Init", {
  hasSupabaseUrl: Boolean(SUPABASE_URL),
  hasSupabaseKey: Boolean(SUPABASE_KEY),
  hasRpcUrl: Boolean(RPC_URL),
  pollingEnabled: ENABLE_POLLING,
  cronSecretConfigured: Boolean(CRON_SECRET),
  webhookSigningConfigured: Boolean(ALCHEMY_SIGNING_KEY)
});
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);
console.log("[update-tickers][boot] Supabase client initialized");
const pricingAbi = parseAbi([
  "function calculateMarkPrice() view returns (uint256)"
]);
const client = createPublicClient({
  transport: http(RPC_URL)
});
console.log("[update-tickers][boot] Viem client initialized");
async function readMarkPrice(address) {
  console.log("[update-tickers] readMarkPrice start", {
    address
  });
  try {
    const raw = await client.readContract({
      address: address,
      abi: pricingAbi,
      functionName: "calculateMarkPrice"
    });
    const price = Number(raw);
    console.log("[update-tickers] readMarkPrice success", {
      address,
      price
    });
    return price;
  } catch (err) {
    console.error("[update-tickers] readMarkPrice error", {
      address,
      error: String(err?.message || err)
    });
    return null;
  }
}
async function upsertTickerAndSeries(marketId, price, isoTs) {
  console.log("[update-tickers] upsertTickerAndSeries start", {
    marketId,
    price,
    isoTs
  });
  if (price != null && price > 0) {
    console.log("[update-tickers] rpc upsert_market_ticker", {
      marketId,
      price,
      isoTs,
      isStale: false
    });
    await supabase.rpc('upsert_market_ticker', {
      p_market_id: marketId,
      p_mark_price: price,
      p_last_update: isoTs,
      p_is_stale: false
    });
    console.log("[update-tickers] rpc upsert_market_ticker done", {
      marketId
    });
    console.log("[update-tickers] rpc insert_market_price", {
      marketId,
      price,
      isoTs
    });
    await supabase.rpc('insert_market_price', {
      p_market_id: marketId,
      p_ts: isoTs,
      p_mark_price: price
    });
    console.log("[update-tickers] rpc insert_market_price done", {
      marketId
    });
  } else {
    console.log("[update-tickers] rpc upsert_market_ticker", {
      marketId,
      price: 0,
      isoTs,
      isStale: true
    });
    await supabase.rpc('upsert_market_ticker', {
      p_market_id: marketId,
      p_mark_price: 0,
      p_last_update: isoTs,
      p_is_stale: true
    });
    console.log("[update-tickers] rpc upsert_market_ticker done", {
      marketId
    });
  }
  console.log("[update-tickers] upsertTickerAndSeries done", {
    marketId
  });
}
function hexAddressLike(value: unknown): string | null {
  if (typeof value !== 'string') return null;
  const v = value.toLowerCase();
  return /^0x[a-f0-9]{40}$/.test(v) ? v : null;
}
function collectAddresses(obj: unknown, out: Set<string> = new Set<string>()) {
  if (!obj) return out;
  if (Array.isArray(obj)) {
    for (const item of obj)collectAddresses(item, out);
    return out;
  }
  if (typeof obj === 'object') {
    for (const v of Object.values(obj)){
      const maybe = hexAddressLike(v);
      if (maybe) out.add(maybe);
      else collectAddresses(v, out);
    }
  }
  return out;
}
async function handlePoll() {
  const startedAt = Date.now();
  console.log('[update-tickers] handlePoll start');
  const { data: markets, error } = await supabase.from('markets').select('id, market_address').eq('is_active', true);
  if (error) {
    console.error('[update-tickers] handlePoll query error', {
      error: error.message
    });
    return new Response(JSON.stringify({
      ok: false,
      error: error.message
    }), {
      status: 500
    });
  }
  console.log('[update-tickers] handlePoll markets', {
    count: (markets || []).length
  });
  const nowIso = new Date().toISOString();
  let updated = 0;
  for (const m of markets || []){
    if (!m.market_address) continue;
    console.log('[update-tickers] handlePoll update', {
      marketId: m.id,
      address: m.market_address
    });
    const price = await readMarkPrice(m.market_address);
    await upsertTickerAndSeries(m.id, price, nowIso);
    updated++;
  }
  console.log('[update-tickers] handlePoll complete', {
    updated,
    durationMs: Date.now() - startedAt
  });
  return new Response(JSON.stringify({
    ok: true,
    updated
  }), {
    headers: {
      'content-type': 'application/json'
    }
  });
}
function toHex(bytes) {
  return Array.from(bytes).map((b)=>b.toString(16).padStart(2, '0')).join('');
}
async function verifyAlchemySignature(req, raw) {
  // If no signing key configured, accept (avoid breaking webhooks in non-secure envs)
  console.log('[update-tickers] verifyAlchemySignature start');
  if (!ALCHEMY_SIGNING_KEY) {
    console.log('[update-tickers] verifyAlchemySignature no signing key configured');
    return {
      valid: true,
      reason: 'no signing key configured'
    };
  }
  const header = req.headers.get('x-alchemy-signature') || req.headers.get('X-Alchemy-Signature') || '';
  if (!header) {
    console.warn('[update-tickers] verifyAlchemySignature missing signature header');
    return {
      valid: false,
      reason: 'missing signature header'
    };
  }
  const enc = new TextEncoder();
  const key = await crypto.subtle.importKey('raw', enc.encode(ALCHEMY_SIGNING_KEY), {
    name: 'HMAC',
    hash: 'SHA-256'
  }, false, [
    'sign'
  ]);
  const sig = await crypto.subtle.sign('HMAC', key, enc.encode(raw));
  const bytes = new Uint8Array(sig);
  const expectedHex = toHex(bytes);
  const expectedB64 = btoa(String.fromCharCode(...bytes));
  const candidateRaw = header.includes('=') ? header.split('=').pop().trim() : header.trim();
  const candidateLower = candidateRaw.toLowerCase();
  const matches = candidateLower === expectedHex || candidateRaw === expectedB64;
  console.log('[update-tickers] verifyAlchemySignature result', {
    valid: matches
  });
  return {
    valid: matches,
    reason: matches ? 'ok' : 'mismatch'
  };
}
function isAuthorizedCron(req) {
  if (!ENABLE_POLLING) {
    console.warn('[update-tickers] isAuthorizedCron disabled: polling not enabled');
    return false;
  }
  if (!CRON_SECRET) {
    console.warn('[update-tickers] isAuthorizedCron disabled: cron secret not configured');
    return false;
  }
  const auth = req.headers.get('authorization') || '';
  if (auth.startsWith('Bearer ') && auth.slice(7).trim() === CRON_SECRET) {
    console.log('[update-tickers] isAuthorizedCron authorized via Bearer');
    return true;
  }
  const url = new URL(req.url);
  if (url.searchParams.get('token') === CRON_SECRET) {
    console.log('[update-tickers] isAuthorizedCron authorized via token param');
    return true;
  }
  console.warn('[update-tickers] isAuthorizedCron unauthorized');
  return false;
}
async function handleWebhook(req) {
  const startedAt = Date.now();
  console.log('[update-tickers] handleWebhook start');
  const raw = await req.text();
  const { valid, reason } = await verifyAlchemySignature(req, raw);
  if (!valid) {
    // Always ACK with 200 to prevent provider from disabling the webhook
    console.warn('[update-tickers] handleWebhook invalid signature', {
      reason
    });
    return new Response(JSON.stringify({
      ok: true,
      ignored: true,
      reason: 'invalid signature',
      detail: reason
    }), {
      status: 200,
      headers: {
        'content-type': 'application/json'
      }
    });
  }
  let payload;
  try {
    payload = JSON.parse(raw);
  } catch  {
    console.warn('[update-tickers] handleWebhook bad json');
    return new Response(JSON.stringify({
      ok: true,
      ignored: true,
      reason: 'bad json'
    }), {
      status: 200,
      headers: {
        'content-type': 'application/json'
      }
    });
  }
  const addresses: string[] = Array.from(collectAddresses(payload));
  console.log('[update-tickers] Addresses', addresses);
  console.log('[update-tickers] Addresses list:', JSON.stringify(addresses, null, 2));
  console.log('[update-tickers] handleWebhook extracted addresses', {
    count: addresses.length
  });
  if (addresses.length === 0) {
    console.log('[update-tickers] handleWebhook no addresses found');
    return new Response(JSON.stringify({
      ok: true,
      updated: 0,
      reason: 'no addresses'
    }), {
      status: 200,
      headers: {
        'content-type': 'application/json'
      }
    });
  }
  // Query only matched markets by address set (case-insensitive exact match)
  const toMatch = addresses;
  const orFilter = toMatch.map((a)=>`market_address.ilike.${a}`).join(',');
  const { data: matched, error } = await supabase
    .from('markets')
    .select('id, market_address')
    .or(orFilter)
    .eq('is_active', true);
  if (error) {
    // Still ACK with 200 to avoid webhook disable
    console.error('[update-tickers] handleWebhook markets query error', {
      error: error.message
    });
    return new Response(JSON.stringify({
      ok: false,
      error: error.message
    }), {
      status: 200,
      headers: {
        'content-type': 'application/json'
      }
    });
  }
  console.log('[update-tickers] handleWebhook matched markets', {
    matched: matched?.length || 0
  });
  const nowIso = new Date().toISOString();
  let updated = 0;
  for (const m of matched || []){
    if (!m.market_address) continue;
    console.log('[update-tickers] handleWebhook update', {
      marketId: m.id,
      address: m.market_address
    });
    const price = await readMarkPrice(m.market_address);
    await upsertTickerAndSeries(m.id, price, nowIso);
    updated++;
  }
  console.log('[update-tickers] handleWebhook complete', {
    updated,
    durationMs: Date.now() - startedAt
  });
  return new Response(JSON.stringify({
    ok: true,
    updated,
    matched: matched?.length || 0
  }), {
    status: 200,
    headers: {
      'content-type': 'application/json'
    }
  });
}
Deno.serve(async (req)=>{
  try {
    const startedAt = Date.now();
    const traceId = req.headers.get('x-trace-id') || `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
    const url = new URL(req.url);
    console.log('[update-tickers] request start', {
      method: req.method,
      path: url.pathname,
      traceId
    });
    if (req.method === 'POST') {
      console.log('[update-tickers] dispatch POST -> handleWebhook', {
        traceId
      });
      return await handleWebhook(req);
    }
    // GET: health by default; optional gated polling if enabled and authorized
    if (req.method === 'GET') {
      if (isAuthorizedCron(req)) {
        console.log('[update-tickers] authorized cron poll', {
          traceId
        });
        return await handlePoll();
      }
      console.log('[update-tickers] health check', {
        traceId
      });
      return new Response(JSON.stringify({
        ok: true,
        message: 'update-tickers alive',
        mode: 'event-driven',
        polling: ENABLE_POLLING ? 'enabled' : 'disabled'
      }), {
        status: 200,
        headers: {
          'content-type': 'application/json'
        }
      });
    }
    console.warn('[update-tickers] method not supported', {
      method: req.method
    });
    return new Response(JSON.stringify({
      ok: true
    }), {
      status: 200
    });
  } catch (err) {
    // Never fail POST webhooks with non-2xx
    if (req.method === 'POST') {
      console.error('[update-tickers] request error (POST)', {
        error: String(err?.message || err)
      });
      return new Response(JSON.stringify({
        ok: false,
        error: String(err?.message || err),
        acknowledged: true
      }), {
        status: 200,
        headers: {
          'content-type': 'application/json'
        }
      });
    }
    console.error('[update-tickers] request error', {
      method: req.method,
      error: String(err?.message || err)
    });
    return new Response(JSON.stringify({
      ok: false,
      error: String(err?.message || err)
    }), {
      status: 500,
      headers: {
        'content-type': 'application/json'
      }
    });
  }
});
