#!/usr/bin/env node

// new-create-market.js - HyperLiquid mainnet: create a new Diamond OrderBook market
//
// Usage (from repo root):
//   npx hardhat --config Dexetrav5/hardhat.config.js \
//     run Dexetrav5/scripts/new-create-market.js --network hyperliquid -- \
//     --symbol GOLD-USD --metric-url "https://example.com/gold" --start-price 2500
//
// Env alternatives:
//   SYMBOL=GOLD-USD METRIC_URL=https://example.com/gold START_PRICE=2500 \
//   npx hardhat --config Dexetrav5/hardhat.config.js run Dexetrav5/scripts/new-create-market.js --network hyperliquid
//
// Notes:
// - Uses existing deployed CoreVault and FuturesMarketFactory (no redeploys)
// - Deploys fresh OrderBook facet contracts for the new Diamond
// - Grants CoreVault roles to the new OrderBook
// - Saves market via API (/api/markets/save) with fallback to Supabase

const { ethers } = require("hardhat");
const fs = require("fs");
const path = require("path");
const { createClient } = require("@supabase/supabase-js");

// Load env from common locations (prefer workspace root .env.local)
try {
  require("dotenv").config({
    path: path.resolve(__dirname, "../../.env.local"),
  });
  require("dotenv").config({ path: path.resolve(__dirname, "../../.env") });
  require("dotenv").config({ path: path.resolve(__dirname, "../.env.local") });
  require("dotenv").config({ path: path.resolve(__dirname, "../.env") });
} catch (_) {}

function getArg(flag, fallback) {
  const idx = process.argv.indexOf(flag);
  if (idx !== -1 && process.argv[idx + 1]) return process.argv[idx + 1];
  return fallback;
}

function getBool(flag, fallback = false) {
  return process.argv.includes(flag) ? true : fallback;
}

function readEnvAny(keys) {
  try {
    const search = Array.isArray(keys) ? keys : [String(keys || "")];
    for (const baseKey of search) {
      if (!baseKey) continue;
      const variants = [baseKey, `NEXT_PUBLIC_${baseKey}`];
      for (const k of variants) {
        const v = process.env[k];
        if (v != null && String(v).trim().length > 0) return String(v).trim();
      }
    }
  } catch (_) {}
  return null;
}

async function fetchWithTimeout(url, options = {}, timeoutMs = 12000) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const gfetch =
      global.fetch ||
      (await (async () =>
        (await import("node-fetch")).then((m) => m.default || m))());
    const res = await gfetch(url, { ...options, signal: controller.signal });
    return res;
  } finally {
    clearTimeout(timer);
  }
}

function loadFacetAbi(contractName) {
  try {
    const artifactPath = path.join(
      __dirname,
      "../artifacts",
      "src",
      "diamond",
      "facets",
      `${contractName}.sol`,
      `${contractName}.json`
    );
    const artifact = require(artifactPath);
    if (artifact && Array.isArray(artifact.abi)) return artifact.abi;
  } catch (_) {}
  return [];
}

function selectorsFromAbi(abi) {
  try {
    const iface = new ethers.Interface(abi);
    return iface.fragments
      .filter((f) => f && f.type === "function")
      .map((f) => ethers.id(f.format("sighash")).slice(0, 10));
  } catch (_) {
    return [];
  }
}

// Deploy a facet contract with detailed logs and return { ctr, addr }
async function deployFacetWithLogs(contractName) {
  const Factory = await ethers.getContractFactory(contractName);
  console.log(`  â€¢ Deploying ${contractName}...`);
  const ctr = await Factory.deploy();
  let depTx = null;
  try {
    depTx =
      typeof ctr.deploymentTransaction === "function"
        ? ctr.deploymentTransaction()
        : ctr.deploymentTransaction || null;
  } catch (_) {
    depTx = ctr.deploymentTransaction || null;
  }
  if (depTx?.hash) {
    console.log(`    - tx: ${depTx.hash}`);
  }
  console.log("    - waiting for deployment...");
  await ctr.waitForDeployment();
  const addr = await ctr.getAddress();
  console.log(`    - deployed at: ${addr}`);
  try {
    if (depTx?.hash) {
      const rc = await ethers.provider.getTransactionReceipt(depTx.hash);
      if (rc) {
        const gasUsed = rc.gasUsed?.toString?.();
        console.log(
          `    - mined: block=${rc.blockNumber}${
            gasUsed ? ` gasUsed=${gasUsed}` : ""
          }`
        );
      }
    }
  } catch (_) {}
  return { ctr, addr };
}

async function resolveCoreContracts(deployer, effectiveNetworkName) {
  // Prefer env, then deployments JSON, then config helper
  const deploymentPath = path.join(
    __dirname,
    `../deployments/${effectiveNetworkName}-deployment.json`
  );
  let coreVaultAddr =
    process.env.CORE_VAULT_ADDRESS || process.env.CORE_VAULT || null;
  let factoryAddr =
    process.env.FUTURES_MARKET_FACTORY_ADDRESS ||
    process.env.FUTURES_MARKET_FACTORY ||
    null;
  try {
    if ((!coreVaultAddr || !factoryAddr) && fs.existsSync(deploymentPath)) {
      const deployment = JSON.parse(fs.readFileSync(deploymentPath, "utf8"));
      coreVaultAddr =
        coreVaultAddr || deployment?.contracts?.CORE_VAULT || null;
      factoryAddr =
        factoryAddr || deployment?.contracts?.FUTURES_MARKET_FACTORY || null;
    }
  } catch (_) {}
  if (!coreVaultAddr || !factoryAddr) {
    const { getContract } = require("../config/contracts");
    const coreVault = (await getContract("CORE_VAULT")).connect(deployer);
    const factory = (await getContract("FUTURES_MARKET_FACTORY")).connect(
      deployer
    );
    return { coreVault, factory };
  }
  const coreVault = await ethers.getContractAt(
    "CoreVault",
    coreVaultAddr,
    deployer
  );
  const factory = await ethers.getContractAt(
    "FuturesMarketFactory",
    factoryAddr,
    deployer
  );
  return { coreVault, factory };
}

async function buildCutViaApiOrEnv() {
  // 1) Try API
  try {
    const baseUrl = (
      process.env.APP_URL ||
      process.env.NEXT_PUBLIC_APP_URL ||
      "http://localhost:3000"
    ).replace(/\/$/, "");
    const res = await fetchWithTimeout(
      `${baseUrl}/api/orderbook/cut`,
      { method: "GET" },
      12000
    );
    if (res && res.ok) {
      const json = await res.json().catch(() => ({}));
      const cut = Array.isArray(json?.cut) ? json.cut : [];
      const initFacet = json?.initFacet || null;
      const cutArg = cut.map((c) => [
        c.facetAddress,
        typeof c.action === "number" ? c.action : 0,
        c.functionSelectors,
      ]);
      if (cutArg.length > 0 && initFacet) return { cutArg, initFacet };
    }
  } catch (_) {}
  // 2) Env fallback
  const initFacet = readEnvAny([
    "ORDER_BOOK_INIT_FACET",
    "ORDERBOOK_INIT_FACET",
    "ORDER_BOOK_INIT_FACET_ADDRESS",
    "ORDERBOOK_INIT_FACET_ADDRESS",
    "FACET_INIT",
    "FACET_INIT_ADDRESS",
    "OB_INIT_FACET",
    "OB_INIT_FACET_ADDRESS",
  ]);
  const adminFacet = readEnvAny([
    "OB_ADMIN_FACET",
    "OB_ADMIN_FACET_ADDRESS",
    "ORDER_BOOK_ADMIN_FACET",
    "ORDERBOOK_ADMIN_FACET",
    "ORDER_BOOK_ADMIN_FACET_ADDRESS",
    "ORDERBOOK_ADMIN_FACET_ADDRESS",
    "FACET_ADMIN",
    "FACET_ADMIN_ADDRESS",
  ]);
  const pricingFacet = readEnvAny([
    "OB_PRICING_FACET",
    "OB_PRICING_FACET_ADDRESS",
    "ORDER_BOOK_PRICING_FACET",
    "ORDERBOOK_PRICING_FACET",
    "ORDER_BOOK_PRICING_FACET_ADDRESS",
    "ORDERBOOK_PRICING_FACET_ADDRESS",
    "FACET_PRICING",
    "FACET_PRICING_ADDRESS",
  ]);
  const placementFacet = readEnvAny([
    "OB_ORDER_PLACEMENT_FACET",
    "OB_ORDER_PLACEMENT_FACET_ADDRESS",
    "ORDER_BOOK_PLACEMENT_FACET",
    "ORDERBOOK_PLACEMENT_FACET",
    "ORDER_BOOK_PLACEMENT_FACET_ADDRESS",
    "ORDERBOOK_PLACEMENT_FACET_ADDRESS",
    "FACET_PLACEMENT",
    "FACET_PLACEMENT_ADDRESS",
  ]);
  const execFacet = readEnvAny([
    "OB_TRADE_EXECUTION_FACET",
    "OB_TRADE_EXECUTION_FACET_ADDRESS",
    "ORDER_BOOK_EXECUTION_FACET",
    "ORDERBOOK_EXECUTION_FACET",
    "ORDER_BOOK_EXECUTION_FACET_ADDRESS",
    "ORDERBOOK_EXECUTION_FACET_ADDRESS",
    "FACET_EXEC",
    "FACET_EXEC_ADDRESS",
  ]);
  const liqFacet = readEnvAny([
    "OB_LIQUIDATION_FACET",
    "OB_LIQUIDATION_FACET_ADDRESS",
    "ORDER_BOOK_LIQUIDATION_FACET",
    "ORDERBOOK_LIQUIDATION_FACET",
    "ORDER_BOOK_LIQUIDATION_FACET_ADDRESS",
    "ORDERBOOK_LIQUIDATION_FACET_ADDRESS",
    "FACET_LIQ",
    "FACET_LIQ_ADDRESS",
  ]);
  const viewFacet = readEnvAny([
    "OB_VIEW_FACET",
    "OB_VIEW_FACET_ADDRESS",
    "ORDER_BOOK_VIEW_FACET",
    "ORDERBOOK_VIEW_FACET",
    "ORDER_BOOK_VIEW_FACET_ADDRESS",
    "ORDERBOOK_VIEW_FACET_ADDRESS",
    "FACET_VIEW",
    "FACET_VIEW_ADDRESS",
  ]);
  const settleFacet = readEnvAny([
    "OB_SETTLEMENT_FACET",
    "OB_SETTLEMENT_FACET_ADDRESS",
    "ORDER_BOOK_SETTLEMENT_FACET",
    "ORDERBOOK_SETTLEMENT_FACET",
    "ORDER_BOOK_SETTLEMENT_FACET_ADDRESS",
    "ORDERBOOK_SETTLEMENT_FACET_ADDRESS",
    "FACET_SETTLEMENT",
    "FACET_SETTLEMENT_ADDRESS",
  ]);
  const missing = [];
  if (!initFacet) missing.push("ORDER_BOOK_INIT_FACET");
  if (!adminFacet) missing.push("OB_ADMIN_FACET");
  if (!pricingFacet) missing.push("OB_PRICING_FACET");
  if (!placementFacet) missing.push("OB_ORDER_PLACEMENT_FACET");
  if (!execFacet) missing.push("OB_TRADE_EXECUTION_FACET");
  if (!liqFacet) missing.push("OB_LIQUIDATION_FACET");
  if (!viewFacet) missing.push("OB_VIEW_FACET");
  if (!settleFacet) missing.push("OB_SETTLEMENT_FACET");
  if (missing.length) {
    throw new Error(`Missing facet env vars: ${missing.join(", ")}`);
  }
  const adminSelectors = selectorsFromAbi(loadFacetAbi("OBAdminFacet"));
  const pricingSelectors = selectorsFromAbi(loadFacetAbi("OBPricingFacet"));
  const placementSelectors = selectorsFromAbi(
    loadFacetAbi("OBOrderPlacementFacet")
  );
  const execSelectors = selectorsFromAbi(loadFacetAbi("OBTradeExecutionFacet"));
  const liqSelectors = selectorsFromAbi(loadFacetAbi("OBLiquidationFacet"));
  const viewSelectors = selectorsFromAbi(loadFacetAbi("OBViewFacet"));
  const settleSelectors = selectorsFromAbi(loadFacetAbi("OBSettlementFacet"));
  const cutArg = [
    [adminFacet, 0, adminSelectors],
    [pricingFacet, 0, pricingSelectors],
    [placementFacet, 0, placementSelectors],
    [execFacet, 0, execSelectors],
    [liqFacet, 0, liqSelectors],
    [viewFacet, 0, viewSelectors],
    [settleFacet, 0, settleSelectors],
  ];
  return { cutArg, initFacet };
}

function getSupabaseClient() {
  try {
    const url =
      process.env.NEXT_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL;
    const serviceKey =
      process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_SERVICE_KEY;
    if (!url || !serviceKey) return null;
    return createClient(url, serviceKey, {
      auth: { autoRefreshToken: false, persistSession: false },
    });
  } catch (_) {
    return null;
  }
}

async function saveMarketDirectSupabase(params) {
  const supabase = getSupabaseClient();
  if (!supabase) return false;
  const {
    marketIdentifier,
    symbol,
    name,
    description,
    category,
    decimals,
    minimumOrderSize,
    settlementDate,
    dataRequestWindowSeconds,
    chainId,
    networkName,
    creatorWalletAddress,
    marketAddress,
    marketIdBytes32,
    transactionHash,
    blockNumber,
    gasUsed,
  } = params;
  const insertPayload = {
    market_identifier: marketIdentifier || symbol,
    symbol,
    name: name || symbol,
    description: description || `OrderBook market for ${symbol}`,
    category: category || "CUSTOM",
    decimals: Number.isFinite(decimals)
      ? decimals
      : Number(process.env.DEFAULT_MARKET_DECIMALS || 8),
    minimum_order_size: Number(process.env.DEFAULT_MINIMUM_ORDER_SIZE || 0.1),
    tick_size: 0.01,
    requires_kyc: false,
    settlement_date: settlementDate
      ? new Date(settlementDate * 1000).toISOString()
      : null,
    data_request_window_seconds: Number(
      dataRequestWindowSeconds ||
        process.env.DEFAULT_DATA_REQUEST_WINDOW_SECONDS ||
        3600
    ),
    auto_settle: true,
    chain_id: chainId,
    network: networkName,
    creator_wallet_address: creatorWalletAddress || null,
    market_address: marketAddress,
    market_id_bytes32: marketIdBytes32,
    deployment_transaction_hash: transactionHash,
    deployment_block_number: blockNumber != null ? Number(blockNumber) : null,
    deployment_gas_used: gasUsed ? Number(gasUsed) : null,
    deployed_at: new Date().toISOString(),
  };
  const { error } = await supabase
    .from("markets")
    .upsert([insertPayload], { onConflict: "market_identifier" });
  if (error) return false;
  return true;
}

function sanitizeSymbolForKey(symbol) {
  try {
    return String(symbol)
      .toUpperCase()
      .replace(/[^A-Z0-9]+/g, "_");
  } catch {
    return "MARKET";
  }
}

async function main() {
  console.log("\nðŸš€ NEW CREATE MARKET (HyperLiquid mainnet)");
  console.log("â•".repeat(80));

  // Validate network
  const network = await ethers.provider.getNetwork();
  const hhName = String(process.env.HARDHAT_NETWORK || "").toLowerCase();
  const isHyperliquid =
    hhName === "hyperliquid" || Number(network.chainId) === 999;
  if (!isHyperliquid) {
    throw new Error(
      "This script is restricted to HyperLiquid mainnet (use --network hyperliquid)."
    );
  }
  const effectiveNetworkName = "hyperliquid";
  console.log(
    `ðŸŒ Network: ${effectiveNetworkName} (Chain ID: ${network.chainId})`
  );

  // Inputs
  const symbol = process.env.SYMBOL || getArg("--symbol") || getArg("-s");
  if (!symbol)
    throw new Error("--symbol is required (e.g., --symbol GOLD-USD)");
  const metricUrl =
    process.env.METRIC_URL ||
    getArg("--metric-url") ||
    getArg("-u") ||
    "https://example.com";
  const startPriceStr =
    process.env.START_PRICE || getArg("--start-price") || getArg("-p") || "1";
  const dataSource =
    process.env.DATA_SOURCE ||
    getArg("--data-source") ||
    getArg("-d") ||
    "User Provided";
  const tagsCsv = process.env.TAGS || getArg("--tags") || "";
  const tags = tagsCsv
    ? tagsCsv
        .split(",")
        .map((t) => t.trim())
        .filter(Boolean)
    : [];
  const marginBps = Number.isFinite(Number(process.env.MARGIN_BPS))
    ? Number(process.env.MARGIN_BPS)
    : Number(getArg("--margin-bps", 10000));
  const feeBps = Number.isFinite(Number(process.env.FEE_BPS))
    ? Number(process.env.FEE_BPS)
    : Number(getArg("--fee-bps", 0));
  const disableLeverage =
    (process.env.DISABLE_LEVERAGE ?? null) !== null
      ? String(process.env.DISABLE_LEVERAGE) !== "false"
      : getBool("--disable-leverage", true);
  const treasury = process.env.TREASURY || getArg("--treasury");

  const startPrice6 = ethers.parseUnits(String(startPriceStr), 6);
  const settlementTs = Math.floor(Date.now() / 1000) + 365 * 24 * 60 * 60;

  let deployer = (await ethers.getSigners())[0];
  if (!deployer) throw new Error("No signer available");
  const feeRecipient = treasury || deployer.address;
  console.log("ðŸ‘¤ Deployer:", deployer.address);
  console.log("ðŸ¦ Treasury:", feeRecipient);
  console.log(
    `ðŸª™ ${symbol} â€¢ start=$${startPriceStr} â€¢ margin=${marginBps}bps â€¢ fee=${feeBps}bps`
  );

  // Resolve Core contracts
  const { coreVault, factory } = await resolveCoreContracts(
    deployer,
    effectiveNetworkName
  );
  console.log("ðŸ”— CoreVault:", await coreVault.getAddress());
  console.log("ðŸ”— FuturesMarketFactory:", await factory.getAddress());

  // Deploy fresh facets (keep core contracts, new OB Diamond facets)
  console.log("\nðŸ”§ Deploying OrderBook facets...");
  const initFacetRes = await deployFacetWithLogs("OrderBookInitFacet");
  const adminFacetRes = await deployFacetWithLogs("OBAdminFacet");
  const pricingFacetRes = await deployFacetWithLogs("OBPricingFacet");
  const placementFacetRes = await deployFacetWithLogs("OBOrderPlacementFacet");
  const execFacetRes = await deployFacetWithLogs("OBTradeExecutionFacet");
  const liqFacetRes = await deployFacetWithLogs("OBLiquidationFacet");
  const viewFacetRes = await deployFacetWithLogs("OBViewFacet");
  const settleFacetRes = await deployFacetWithLogs("OBSettlementFacet");

  const initFacetCtr = initFacetRes.ctr;
  const adminFacetCtr = adminFacetRes.ctr;
  const pricingFacetCtr = pricingFacetRes.ctr;
  const placementFacetCtr = placementFacetRes.ctr;
  const execFacetCtr = execFacetRes.ctr;
  const liqFacetCtr = liqFacetRes.ctr;
  const viewFacetCtr = viewFacetRes.ctr;
  const settlementFacetCtr = settleFacetRes.ctr;

  function selectorsFromInterface(iface) {
    return iface.fragments
      .filter((f) => f.type === "function")
      .map((f) => ethers.id(f.format("sighash")).slice(0, 10));
  }

  const initFacet = initFacetRes.addr;
  const adminAddr = adminFacetRes.addr;
  const pricingAddr = pricingFacetRes.addr;
  const placementAddr = placementFacetRes.addr;
  const execAddr = execFacetRes.addr;
  const liqAddr = liqFacetRes.addr;
  const viewAddr = viewFacetRes.addr;
  const settleAddr = settleFacetRes.addr;

  try {
    console.log("\nðŸ”Ž Facets (deployed):");
    console.log("  â€¢ initFacet:", initFacet);
    console.log("  â€¢ adminFacet:", adminAddr);
    console.log("  â€¢ pricingFacet:", pricingAddr);
    console.log("  â€¢ placementFacet:", placementAddr);
    console.log("  â€¢ execFacet:", execAddr);
    console.log("  â€¢ liqFacet:", liqAddr);
    console.log("  â€¢ viewFacet:", viewAddr);
    console.log("  â€¢ settleFacet:", settleAddr);
  } catch (_) {}

  const adminSelectors = selectorsFromInterface(adminFacetCtr.interface);
  const pricingSelectors = selectorsFromInterface(pricingFacetCtr.interface);
  const placementSelectors = selectorsFromInterface(
    placementFacetCtr.interface
  );
  const execSelectors = selectorsFromInterface(execFacetCtr.interface);
  const liqSelectors = selectorsFromInterface(liqFacetCtr.interface);
  const viewSelectors = selectorsFromInterface(viewFacetCtr.interface);
  const settleSelectors = selectorsFromInterface(settlementFacetCtr.interface);

  try {
    console.log("\nðŸ§® Selector counts per facet:");
    console.log(`  â€¢ admin: ${adminSelectors.length}`);
    console.log(`  â€¢ pricing: ${pricingSelectors.length}`);
    console.log(`  â€¢ placement: ${placementSelectors.length}`);
    console.log(`  â€¢ exec: ${execSelectors.length}`);
    console.log(`  â€¢ liquidation: ${liqSelectors.length}`);
    console.log(`  â€¢ view: ${viewSelectors.length}`);
    console.log(`  â€¢ settlement: ${settleSelectors.length}`);
  } catch (_) {}

  const cutArg = [
    [adminAddr, 0, adminSelectors],
    [pricingAddr, 0, pricingSelectors],
    [placementAddr, 0, placementSelectors],
    [execAddr, 0, execSelectors],
    [liqAddr, 0, liqSelectors],
    [viewAddr, 0, viewSelectors],
    [settleAddr, 0, settleSelectors],
  ];

  // Create market
  console.log("\nðŸ­ Creating market via FuturesMarketFactory...");
  console.log("  â€¢ symbol:", symbol);
  console.log("  â€¢ metricUrl:", metricUrl);
  console.log("  â€¢ settlementDate:", settlementTs);
  // Preflight estimate + static call
  try {
    const estimateFn = factory.getFunction("createFuturesMarketDiamond");
    const gas = await estimateFn.estimateGas(
      symbol,
      metricUrl,
      settlementTs,
      startPrice6,
      dataSource,
      tags,
      feeRecipient,
      cutArg,
      initFacet,
      "0x"
    );
    console.log("  â€¢ estimatedGas:", gas.toString());
  } catch (e) {
    console.log("  â€¢ gas estimation failed:", e?.message || e);
  }
  try {
    await factory
      .getFunction("createFuturesMarketDiamond")
      .staticCall(
        symbol,
        metricUrl,
        settlementTs,
        startPrice6,
        dataSource,
        tags,
        feeRecipient,
        cutArg,
        initFacet,
        "0x"
      );
    console.log("  â€¢ staticCall: OK");
  } catch (e) {
    console.log("  â€¢ staticCall reverted (continuing):", e?.message || e);
  }
  console.log("  â€¢ sending transaction...");
  const tx = await factory.createFuturesMarketDiamond(
    symbol,
    metricUrl,
    settlementTs,
    startPrice6,
    dataSource,
    tags,
    feeRecipient,
    cutArg,
    initFacet,
    "0x"
  );
  console.log("  â€¢ tx:", tx.hash);
  console.log("  â€¢ awaiting confirmation...");
  const receipt = await tx.wait();
  console.log(
    `  âœ… Market created (block=${receipt?.blockNumber}${
      receipt?.gasUsed ? ` gasUsed=${receipt.gasUsed.toString()}` : ""
    })`
  );

  // Parse event
  let orderBook, marketId;
  for (const log of receipt.logs || []) {
    try {
      const parsed = factory.interface.parseLog(log);
      if (parsed.name === "FuturesMarketCreated") {
        orderBook = parsed.args.orderBook;
        marketId = parsed.args.marketId;
        break;
      }
    } catch (_) {}
  }
  if (!orderBook || !marketId)
    throw new Error("Failed to parse FuturesMarketCreated event");
  console.log("  â€¢ OrderBook:", orderBook);
  console.log("  â€¢ Market ID:", marketId);

  // Configure trading parameters
  console.log("\nðŸ”’ Configuring trading params and roles...");
  const obAdmin = await ethers.getContractAt(
    "OBAdminFacet",
    orderBook,
    deployer
  );
  try {
    console.log(
      `  â€¢ updateTradingParameters(marginBps=${marginBps}, feeBps=${feeBps}, treasury=${feeRecipient})`
    );
    const t1 = await obAdmin.updateTradingParameters(
      marginBps,
      feeBps,
      feeRecipient
    );
    console.log("    - tx:", t1.hash);
    const r1 = await t1.wait();
    console.log(
      `  âœ… Trading parameters updated (block=${r1?.blockNumber}${
        r1?.gasUsed ? ` gasUsed=${r1.gasUsed.toString()}` : ""
      })`
    );
  } catch (e) {
    console.log("  âš ï¸ updateTradingParameters failed:", e?.message || e);
  }
  if (disableLeverage) {
    try {
      console.log("  â€¢ disableLeverage()");
      const t2 = await obAdmin.disableLeverage();
      console.log("    - tx:", t2.hash);
      const r2 = await t2.wait();
      console.log(
        `  âœ… Leverage disabled (block=${r2?.blockNumber}${
          r2?.gasUsed ? ` gasUsed=${r2.gasUsed.toString()}` : ""
        })`
      );
    } catch (_) {}
  }
  try {
    const ORDERBOOK_ROLE = ethers.keccak256(
      ethers.toUtf8Bytes("ORDERBOOK_ROLE")
    );
    const SETTLEMENT_ROLE = ethers.keccak256(
      ethers.toUtf8Bytes("SETTLEMENT_ROLE")
    );
    console.log("  â€¢ grantRole(ORDERBOOK_ROLE, orderBook)");
    const tA = await coreVault.grantRole(ORDERBOOK_ROLE, orderBook);
    console.log("    - tx:", tA.hash);
    const rA = await tA.wait();
    console.log(
      `    - mined (block=${rA?.blockNumber}${
        rA?.gasUsed ? ` gasUsed=${rA.gasUsed.toString()}` : ""
      })`
    );
    console.log("  â€¢ grantRole(SETTLEMENT_ROLE, orderBook)");
    const tB = await coreVault.grantRole(SETTLEMENT_ROLE, orderBook);
    console.log("    - tx:", tB.hash);
    const rB = await tB.wait();
    console.log(
      `    - mined (block=${rB?.blockNumber}${
        rB?.gasUsed ? ` gasUsed=${rB.gasUsed.toString()}` : ""
      })`
    );
    console.log("  âœ… Roles granted on CoreVault");
  } catch (e) {
    console.log("  âš ï¸ Role grant failed:", e?.message || e);
  }

  // Save to DB via API; fallback to Supabase
  const initialOrder = {
    metricUrl,
    startPrice: String(ethers.formatUnits(startPrice6, 6)),
    dataSource,
    tags,
  };
  let saved = false;
  try {
    const baseUrl = (
      process.env.APP_URL ||
      process.env.NEXT_PUBLIC_APP_URL ||
      "http://localhost:3000"
    ).replace(/\/$/, "");
    console.log(`\nðŸ—„ï¸  Saving market via API â†’ ${baseUrl}/api/markets/save`);
    const res = await fetchWithTimeout(
      `${baseUrl}/api/markets/save`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          marketIdentifier: symbol,
          symbol,
          name: `${(symbol.split("-")[0] || symbol).toUpperCase()} Futures`,
          description: `OrderBook market for ${symbol}`,
          category: Array.isArray(tags) && tags.length ? tags[0] : "CUSTOM",
          decimals: Number(process.env.DEFAULT_MARKET_DECIMALS || 8),
          minimumOrderSize: Number(
            process.env.DEFAULT_MINIMUM_ORDER_SIZE || 0.1
          ),
          settlementDate: settlementTs,
          tradingEndDate: null,
          dataRequestWindowSeconds: Number(
            process.env.DEFAULT_DATA_REQUEST_WINDOW_SECONDS || 3600
          ),
          autoSettle: true,
          oracleProvider: null,
          initialOrder,
          chainId: Number(network.chainId),
          networkName: effectiveNetworkName,
          creatorWalletAddress: deployer.address,
          marketAddress: orderBook,
          marketIdBytes32: marketId,
          transactionHash: receipt?.hash || null,
          blockNumber: receipt?.blockNumber || null,
          gasUsed: receipt?.gasUsed?.toString?.() || null,
        }),
      },
      12000
    );
    if (res) {
      console.log(
        `  â€¢ API response: ${res.status} ${res.statusText || ""}`.trim()
      );
    }
    if (res && res.ok) {
      console.log("ðŸ—„ï¸  âœ… Market saved via API");
      saved = true;
    } else if (res) {
      try {
        const body = await res.json();
        if (body?.error) console.log("  â€¢ API error:", body.error);
      } catch (_) {}
    }
  } catch (_) {}
  if (!saved) {
    console.log("ðŸ—„ï¸  Falling back to Supabase direct upsert...");
    const ok = await saveMarketDirectSupabase({
      marketIdentifier: symbol,
      symbol,
      name: `${(symbol.split("-")[0] || symbol).toUpperCase()} Futures`,
      description: `OrderBook market for ${symbol}`,
      category: Array.isArray(tags) && tags.length ? tags[0] : "CUSTOM",
      decimals: Number(process.env.DEFAULT_MARKET_DECIMALS || 8),
      minimumOrderSize: Number(process.env.DEFAULT_MINIMUM_ORDER_SIZE || 0.1),
      settlementDate: settlementTs,
      dataRequestWindowSeconds: Number(
        process.env.DEFAULT_DATA_REQUEST_WINDOW_SECONDS || 3600
      ),
      chainId: Number(network.chainId),
      networkName: effectiveNetworkName,
      creatorWalletAddress: deployer.address,
      marketAddress: orderBook,
      marketIdBytes32: marketId,
      transactionHash: receipt?.hash || null,
      blockNumber: receipt?.blockNumber || null,
      gasUsed: receipt?.gasUsed?.toString?.() || null,
    });
    console.log(
      ok
        ? "ðŸ—„ï¸  âœ… Market saved via Supabase"
        : "ðŸ—„ï¸  âš ï¸ DB save skipped (no Supabase env)"
    );
  }

  // Update deployments JSON
  const deploymentPath = path.join(
    __dirname,
    `../deployments/${effectiveNetworkName}-deployment.json`
  );
  let deployment = {};
  try {
    if (fs.existsSync(deploymentPath)) {
      deployment = JSON.parse(fs.readFileSync(deploymentPath, "utf8"));
    }
  } catch (_) {}
  deployment.network = effectiveNetworkName;
  deployment.chainId = Number(network.chainId);
  deployment.timestamp = new Date().toISOString();
  deployment.contracts = deployment.contracts || {};
  const keyBase = sanitizeSymbolForKey(symbol.split("-")[0] || symbol);
  deployment.contracts[`${keyBase}_ORDERBOOK`] = orderBook;
  deployment.contracts[`${keyBase}_MARKET_ID`] = marketId;
  deployment.markets = Array.isArray(deployment.markets)
    ? deployment.markets
    : [];
  const entry = {
    symbol,
    marketId,
    orderBook,
    metricUrl,
    settlementDate: settlementTs,
    startPrice: startPrice6.toString(),
    dataSource,
    tags,
  };
  const existingIdx = deployment.markets.findIndex((m) => m.symbol === symbol);
  if (existingIdx >= 0) deployment.markets[existingIdx] = entry;
  else deployment.markets.push(entry);
  fs.writeFileSync(deploymentPath, JSON.stringify(deployment, null, 2));
  console.log(
    "ðŸ“  âœ… Deployment updated:",
    path.relative(process.cwd(), deploymentPath)
  );

  console.log("\nâœ… Market ready!");
  console.log("â•".repeat(80));
  console.log(`ðŸŽ¯ ${symbol} â†’ ${orderBook}`);
}

main()
  .then(() => process.exit(0))
  .catch((e) => {
    console.error(e);
    process.exit(1);
  });
